#pragma config(Sensor, in1,    Rsensor,        sensorAnalog)
#pragma config(Sensor, in2,    Msensor,        sensorAnalog)
#pragma config(Sensor, in3,    Lsensor,        sensorAnalog)
#pragma config(Sensor, dgtl2,  Limit3,         sensorDigitalIn)
#pragma config(Sensor, dgtl3,  Limit2,         sensorDigitalIn)
#pragma config(Sensor, dgtl4,  Limit4,         sensorDigitalIn)
#pragma config(Sensor, dgtl5,  Line2,          sensorDigitalIn)
#pragma config(Sensor, dgtl6,  Line4,          sensorDigitalIn)
#pragma config(Sensor, dgtl8,  compassSupply,  sensorDigitalOut)
#pragma config(Sensor, dgtl9,  compassNorth,   sensorDigitalIn)
#pragma config(Sensor, dgtl10, compassEast,    sensorDigitalIn)
#pragma config(Sensor, dgtl11, compassSouth,   sensorDigitalIn)
#pragma config(Sensor, dgtl12, compassWest,    sensorDigitalIn)
#pragma config(Motor,  port2,           motor1,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port3,           motor2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           scoopmotor,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// front is side 1, left is side 2, back is side 3, right side is side 4
int flag = 0;
int scoopflag = 0;

bool ballDetect = false;
bool leftDetect = false;
bool rightDetect = false;
int	ballDone=0;
int ballSize = 400; //half of the ball, depend on curve
int i = 1;
int j = 1; //while loop flag for traveltoball

void travelToBall() {
	while(true){
		setMultipleMotors(25, motor1, motor2); //correcting for one motor being a bit stronger
		if ((SensorValue(Msensor)>1900) || (SensorValue(Lsensor)>1900) || (SensorValue(Rsensor)>1900)) {
			motor[motor1] = 0;
			motor[motor2] = 0;
			break;

		}

	}
	wait1Msec(1000);

}

void reverse() {

	while (SensorValue(Limit3)==1) {
		setMultipleMotors(-25, motor1, motor2)
	}
	motor[motor1] = 0;
	motor[motor2] = 0;
}

void llcheck(){
	if (leftDetect == true){
		motor[motor1] = -25; //want opposite motor to reverse
		wait1Msec(1000);
		motor[motor1] = 0;
		wait1Msec(1000);
		leftDetect = false;
		//black is 1 yellow is 0
	}
	if (rightDetect == true){
		motor[motor2] = -25;
		wait1Msec(1000);
		motor[motor2] = 0;
		wait1Msec(1000);
		rightDetect = false;
	}
}

void moveFwd() {
	while (ballDetect == false)
	{
		clearTimer(T1);
		while (time1[T1]<1000) {
			setMultipleMotors(30, motor1, motor2);
			if (ballDetect == true){
				motor[motor1] = 0;
				motor[motor2] = 0;
				break;
			}
			llcheck();
		}
		motor[motor1] = 0;
		motor[motor2] = 0;
		break;
	}
}



void rotate60() {
	while (ballDetect == false){
		clearTimer(T2);
		while (time1[T2]<1500) {	
			motor[motor1] = -20;
			motor[motor2] = 0;
			if (ballDetect == true){
				motor[motor1] = 0;
				motor[motor2] = 0;
				break;
			}
			llcheck();
		}
		clearTimer(T1);
		while (time1[T1]<1500) {	
			motor[motor1] = 20;
			motor[motor2] = 0;
			if (ballDetect == true){
				motor[motor1] = 0;
				motor[motor2] = 0;
				break;
			}
			llcheck();
		}
		clearTimer(T3); 
		while (time1[T3]<1500) {
			motor[motor1] = 0;
			motor[motor2] = -20;
			if (ballDetect == true){
				motor[motor1] = 0;
				motor[motor2] = 0;
				break;
			}
			llcheck();
		}

		clearTimer(T4); 
		while (time1[T4]<1500) {
			motor[motor1] = 0;
			motor[motor2] = 20;
			if (ballDetect == true){
				motor[motor1] = 0;
				motor[motor2] = 0;
				break;
			}
			llcheck();
		}

		motor[motor1] = 0;
		motor[motor2] = 0;	
		wait1Msec(100);
		break;
	}
}


void pivot() {

	//function to pivot when traveltoball is completed, and before scoop
	if ((SensorValue(Msensor)>1900) || (SensorValue(Rsensor)>1900)){
		motor[motor1] = 25 ;
		motor[motor2] = -25 ;
		wait1Msec(300);
		setMultipleMotors(25, motor1, motor2)
		wait1Msec(600);
		motor[motor1] = 0;
		motor[motor2] = 0;
		wait1Msec(400);
	}
	if (SensorValue(Lsensor)>1900){
		motor[motor1] = 25 ;
		motor[motor2] = -25 ;
		wait1Msec(100);
		setMultipleMotors(25, motor1, motor2)
		wait1Msec(600);
		motor[motor1] = 0;
		motor[motor2] = 0;
		wait1Msec(400);
	}
}

void scoop()
{

	setMultipleMotors(25, motor1, motor2)
	wait1Msec(300);
	motor[scoopmotor] = 50;
	wait1Msec(500);
	motor[scoopmotor] = 0;
	motor[motor1] = 0;
	motor[motor2] = 0;

	wait1Msec(1000);
	// 250 causes a roughly 60 degree rotation

}

void deliver()
{
	motor[scoopmotor] = 127;
	wait1Msec(450);
	motor[scoopmotor] = 0;
	wait1Msec(100);



}


void toDelPos() {

	while(true){
		motor[motor1] = -20;
		motor[motor2] = 20;
		scoopflag = 1;
		if ((SensorValue(compassWest)== 1)&&(SensorValue(compassNorth)== 1)
			&&(SensorValue(compassEast)== 1)&&(SensorValue(compassSouth)== 0)) {
			flag = 1;
			motor[motor1] = 0;
			motor[motor2] = 0;
			break;
		}
	}
	wait1Msec(100);
}

task searchBall() {
	int	ballDone=0;
	// this is darren's scan function

	while (true){
		int M = SensorValue(Msensor);
		int L = SensorValue(Lsensor);
		int R = SensorValue(Rsensor);
		if(((SensorValue(Msensor)-SensorValue(Lsensor))>ballSize) &&
			((SensorValue(Msensor)-SensorValue(Rsensor))>ballSize)){
			ballDetect = true;
		}
		else{
			if (ballDone<3) {
				ballDetect = false;

			}
		}
	}
}

task linelimitScan () {
	//must disregard line2 while testing on floor because it will always trigger
	while (true){
		if (/*(SensorValue(Line2)==0)||*/(SensorValue(Limit2)==0)) {
			leftDetect = true;
		}

		if (/*(SensorValue(Line4)==0)||*/(SensorValue(Limit4)==0)) {
			rightDetect = true;
		}
	}
}

task driveControl(){
	while(true){
		if (ballDetect == true){
			stopTask(searchBall);
			ballDetect = false
			travelToBall();
			pivot(); //WIP parameters
			scoop();  //WIP parameters
			toDelPos(); //north west is the right direction //working
			wait1Msec(1000); //to TEST
			//resetting flag for todelpos()
			reverse();
			deliver();
			rightDetect = false;
			leftDetect = false;
			ballDone++;
			startTask(searchBall);
		}
		else if (ballDetect == false){
				moveFwd(); //working
				rotate60();} //working
		else{
		}
	}
}

task main(){
	//	startTask(linelimitScan); //working
	startTask(driveControl);
	startTask(searchBall);
	startTask(linelimitScan);
	while(true) {
		int batt = nImmediateBatteryLevel;

	}
}
