#pragma config(Sensor, in1,    Rsensor,        sensorAnalog)
#pragma config(Sensor, in2,    Msensor,        sensorAnalog)
#pragma config(Sensor, in3,    Lsensor,        sensorAnalog)
#pragma config(Sensor, dgtl2,  Limit3,         sensorDigitalIn)
#pragma config(Sensor, dgtl3,  Limit2,         sensorDigitalIn)
#pragma config(Sensor, dgtl4,  Limit4,         sensorDigitalIn)
#pragma config(Sensor, dgtl5,  Line2,          sensorDigitalIn)
#pragma config(Sensor, dgtl6,  Line4,          sensorDigitalIn)
#pragma config(Sensor, dgtl8,  compassSupply,  sensorDigitalOut)
#pragma config(Sensor, dgtl9,  compassNorth,   sensorDigitalIn)
#pragma config(Sensor, dgtl10, compassEast,    sensorDigitalIn)
#pragma config(Sensor, dgtl11, compassSouth,   sensorDigitalIn)
#pragma config(Sensor, dgtl12, compassWest,    sensorDigitalIn)
#pragma config(Motor,  port2,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           motor2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           scoopmotor,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// front is side 1, left is side 2, back is side 3, right side is side 4
int flag = 0;
int scoopflag = 0;

void travelToBall(int dist) {
	int travelDist = dist - 50;
	motor[motor1]=-127;
	motor[motor2]=127;
	int intermediate = (1/travelDist) + 0.42; //formula to linearize sensor data
	int timeToGo = intermediate*27; //adjusted based on how long it takes to move to ball
	wait1Msec(timeToGo);
	motor[motor1]=0;
	motor[motor2]=0;

}

 task linelimitScan () {
	while (true){
		if ((SensorValue(Line2)==0)||(SensorValue(Line4)==0)) {
			motor[motor1] = -25; //want opposite motor to reverse
			motor[motor1] = 25; //want opposite motor to reverse
			wait1Msec(2000);
			motor[motor1] = 0;
			motor[motor2] = 0;
			wait1Msec(1000);


		}
		if ((SensorValue(Line2)==0)||(SensorValue(Limit2)==0)) {
			motor[motor1] = 25; //want opposite motor to reverse
			wait1Msec(1000);
			motor[motor1] = 0;
			wait1Msec(1000);

			//black is 1 yellow is 0
		}

		if ((SensorValue(Line4)==0)||(SensorValue(Limit4)==0)) {

			motor[motor2] = -25;
			wait1Msec(2000);
			motor[motor2] = 0;
			wait1Msec(1000);

		}

	}
} 

void reverse() {

	/*	switch (SensorValue(Limit3))
	case 0:
	motor[motor1] = -25;
	motor[motor2] = 25;
	case 1:
	motor[motor1] = 0;
	motor[motor2] = 0;
	break; */

	while (SensorValue(Limit3)==0) {
		motor[motor1] = -25;
		motor[motor2] = 25;
	}
	motor[motor1] = 0;
	motor[motor2] = 0;


}

void moveFwd() {

	motor[motor1] = 120;
	motor[motor2] = -120;
	wait1Msec(2000);
}



void rotate60() {

	motor[motor1] = -25;
	motor[motor2] = -25;
	wait1Msec(1000);
	motor[motor1] = 25;
	motor[motor2] = 25;
	wait1Msec(1000);
}


void scoop()
{

	motor[scoopmotor] = 50;
	wait1Msec(1000);
	flag = 1;
	motor[scoopmotor] = 0;

	wait1Msec(1000);
	// 250 causes a roughly 60 degree rotation

}

void pivot() {
	
//function to pivot when traveltoball is completed, and before scoop

	motor[motor1] = 25 ; 
	wait1Msec(250); 
	motor[motor1] = 0; 
	
}

void deliver()
{
	motor[scoopmotor] = 127;
	wait1Msec(450);
	motor[scoopmotor] = 0;
	wait1Msec(2000);

}


void toDelPos() {

	while ((SensorValue(compassWest)!= 1)&&(SensorValue(compassNorth)!= 1)
		&&(SensorValue(compassEast)!= 0)&&(SensorValue(compassSouth)!= 0)){
		motor[motor1] = -25;
		motor[motor2] = -25;
	}

	motor[motor1] = 0;
	motor[motor2] = 0;

}

task detectBall() {
	int ballDone = 0;
	// this is darren's scan function
	int ballSize = 300; //half of the ball, depend on curve
		while (true){
		int M = SensorValue(Msensor);
		int L = SensorValue(Lsensor);
		int R = SensorValue(Rsensor); 
		if(((M-L)>ballSize) && ((M-R)>ballSize)){
			travelToBall(M);
			scoop();
			scoopflag = 1;
			pivot(); 
			toDelPos(); //north west is the right direction
			reverse();
			deliver();
			ballDone++; 
		}
		else{

			if (ballDone<3) {
			moveFwd();
			rotate60();} 
		} 
	}
}


task main(){
		startTask(linelimitScan);
		startTask(detectBall);
	while(true) {

}
}
