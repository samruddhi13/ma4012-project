#pragma config(Sensor, in1,    Rsensor,        sensorAnalog)
#pragma config(Sensor, in2,    Msensor,        sensorAnalog)
#pragma config(Sensor, in3,    Lsensor,        sensorAnalog)
#pragma config(Sensor, dgtl2,  Limit3,         sensorDigitalIn)
#pragma config(Sensor, dgtl3,  Limit2,         sensorDigitalIn)
#pragma config(Sensor, dgtl4,  Limit4,         sensorDigitalIn)
#pragma config(Sensor, dgtl5,  Line2,          sensorDigitalIn)
#pragma config(Sensor, dgtl6,  Line4,          sensorDigitalIn)
#pragma config(Sensor, dgtl8,  compassSupply,  sensorDigitalOut)
#pragma config(Sensor, dgtl9,  compassNorth,   sensorDigitalIn)
#pragma config(Sensor, dgtl10, compassEast,    sensorDigitalIn)
#pragma config(Sensor, dgtl11, compassSouth,   sensorDigitalIn)
#pragma config(Sensor, dgtl12, compassWest,    sensorDigitalIn)
#pragma config(Motor,  port2,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           motor2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           scoopmotor,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// front is side 1, left is side 2, back is side 3, right side is side 4
int flag = 0;
int scoopflag = 0;

int ballSize = 300; //half of the ball, depend on curve
int i = 1;
int j = 1; //while loop flag for traveltoball

void travelToBall(int dist) {
		while(true){
		motor[motor1] = -20; //correcting for one motor being a bit stronger
		motor[motor2] = 25;
		if (SensorValue(Msensor)>1900) {
			motor[motor1] = 0;
			motor[motor2] = 0;
			break;
			
		}
		
	}
		wait1Msec(1000);
		
}
/*	int travelDist = dist - 400;
	motor[motor1]=-50;
	motor[motor2]=50;
	float distance = 30431 * pow(travelDist, -1.169);//adjusted based on how long it takes to move to ball
	wait1Msec((distance/14)*1000); //14 chosen because not running at full speedm 36 for full speed
	motor[motor1]=0;
	motor[motor2]=0;
	wait1Msec(3000); */

task linelimitScan () {
	//must disregard line2 while testing on floor because it will always trigger
	while (true){
		if (/*(SensorValue(Line2)==0)||*/(SensorValue(Line4)==0)) {
			motor[motor1] = -25; //want opposite motor to reverse
			motor[motor1] = 25; //want opposite motor to reverse
			wait1Msec(2000);
			motor[motor1] = 0;
			motor[motor2] = 0;
			wait1Msec(1000);


		}
		if (/*(SensorValue(Line2)==0)||*/(SensorValue(Limit2)==0)) {
			motor[motor1] = 25; //want opposite motor to reverse
			wait1Msec(1000);
			motor[motor1] = 0;
			wait1Msec(1000);

			//black is 1 yellow is 0
		}

		if ((SensorValue(Line4)==0)||(SensorValue(Limit4)==0)) {

			motor[motor2] = -25;
			wait1Msec(2000);
			motor[motor2] = 0;
			wait1Msec(1000);

		}

	}
}

void reverse() {

	while (SensorValue(Limit3)==1) {
		motor[motor1] = 25;
		motor[motor2] = -25;
	}
	motor[motor1] = 0;
	motor[motor2] = 0;


}

void moveFwd() {
	while (((SensorValue(Msensor)-SensorValue(Lsensor))<ballSize) && ((SensorValue(Msensor)-SensorValue(Rsensor))<ballSize)){
{
		motor[motor1] = -25;
		motor[motor2] = 25;
		wait1Msec(2000);
	}
}

}

void rotate60() {
	while (((SensorValue(Msensor)-SensorValue(Lsensor))<ballSize) && ((SensorValue(Msensor)-SensorValue(Rsensor))<ballSize)){
		motor[motor1] = -25;
		motor[motor2] = -25;
		wait1Msec(1000);
		motor[motor1] = 25;
		motor[motor2] = 25;
		wait1Msec(2*1000);
		motor[motor1] = -25;
		motor[motor2] = -25;
		wait1Msec(1000);
	}
}

void scoop()
{
	
  motor[motor1] = -25;
  motor[motor2] = 25;
	flag = 1;
	wait1Msec(300);
	motor[scoopmotor] = 100;
	wait1Msec(500);
	motor[scoopmotor] = 0;
	motor[motor1] = 0;
	motor[motor2] = 0;

	wait1Msec(1000);
	// 250 causes a roughly 60 degree rotation

}

void pivot() {

	//function to pivot when traveltoball is completed, and before scoop

		motor[motor1] = -25 ;
	motor[motor2] = -25 ;
	wait1Msec(300);
	motor[motor1] = -25;
	motor[motor2] = 25;
	wait1Msec(600);
	motor[motor1] = 0;
	motor[motor2] = 0;
	wait1Msec(400);

}

void deliver()
{
	motor[scoopmotor] = 127;
	wait1Msec(450);
	motor[scoopmotor] = 0;
	wait1Msec(2000);

}


void toDelPos() {

	while(i = 1){
		motor[motor1] = 25;
		motor[motor2] = 25;
		if ((SensorValue(compassWest)== 1)&&(SensorValue(compassNorth)== 1)
			&&(SensorValue(compassEast)== 1)&&(SensorValue(compassSouth)== 0)) {
			motor[motor1] = 0;
			motor[motor2] = 0;
			i = 0;
		}

		wait1Msec(5000);


	}
}

task detectBall() {
	int	ballDone=0;
	// this is darren's scan function

	while (true){
		int M = SensorValue(Msensor);
		int L = SensorValue(Lsensor);
		int R = SensorValue(Rsensor);
		if(((SensorValue(Msensor)-SensorValue(Lsensor))<ballSize) && ((SensorValue(Msensor)-SensorValue(Rsensor))<ballSize)){
		scoopflag = 1;
		travelToBall(M);
		flag = 1;
	  pivot(); //WIP parameters
	  scoopflag = 1; 
			scoop();  //WIP parameters
	/*		scoopflag = 1;
		//	toDelPos(); //north west is the right direction //working
			wait1Msec(1000); //to TEST
			flag = 1;
			 //resetting flag for todelpos()
			reverse();
			deliver();
			ballDone++;  */
		}
		/*	else{

		if (ballDone<3) {
		moveFwd(); //working
		rotate60();} //working 
		} */
	}
}


task main(){
	//	startTask(linelimitScan); //working
	startTask(detectBall);
	while(true) {

	}
}
