#pragma config(Sensor, in1,    Msensor,        sensorAnalog)
#pragma config(Sensor, in2,    Lsensor,        sensorAnalog)
#pragma config(Sensor, in3,    Rsensor,        sensorAnalog)
#pragma config(Sensor, dgtl8, compassSupply,  sensorDigitalOut)
#pragma config(Sensor, dgtl12,  compassWest,    sensorDigitalIn)
#pragma config(Sensor, dgtl11,  compassSouth,   sensorDigitalIn)
#pragma config(Sensor, dgtl10, compassEast,    sensorDigitalIn)
#pragma config(Sensor, dgtl9, compassNorth,   sensorDigitalIn)
#pragma config(Sensor, dgtl2,  Line2,          sensorDigitalIn)
#pragma config(Sensor, dgtl3,  Line4,          sensorDigitalIn)
#pragma config(Sensor, dgtl4,  Limit2,         sensorDigitalIn)
#pragma config(Sensor, dgtl5,  Limit3,         sensorDigitalIn)
#pragma config(Sensor, dgtl6,  Limit4,         sensorDigitalIn)
#pragma config(Motor,  port2,           motor1,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           motor2,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           scoopmotor,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// front is side 1, left is side 2, back is side 3, right side is side 4


int lineScan () {
	if (SensorValue(Line2)==1) {
		return 1;
	}
	if (SensorValue(Line4)==1) {
		return 2;
	}
	else return 0;
}

void SideRun() {

	if ((SensorValue(Line2)==1)||(SensorValue(Limit2)==1)) {
		motor(motor1) = 25; //want opposite motor to reverse 
		wait1Msec(1000);
		motor(motor1) = 25;
		wait1Msec(1000);
	
	
}

if ((SensorValue(Line4)==1)||(SensorValue(Limit4)==1)) {
		
		motor(motor2) = -25;
		wait1Msec(2000);
		motor(motor1) = 0;
		wait1Msec(1000);	
}

}
void reverse() {

	/*	switch (SensorValue(Limit3))
	case 0:
		motor(motor1) = -25;
		motor(motor2) = 25;
	case 1:
		motor(motor1) = 0;
		motor(motor2) = 0;
		break; */

	while (SensorValue(Limit3)<1) {
			motor(motor1) = -25;
			motor(motor2) = 25;
}
	    motor(motor1) = 0;
			motor(motor2) = 0;


}

void moveFwd() {

	motor(motor1) = 25;
	motor(motor2) = -25;
	wait1Msec(2000);
}

int detectBall() {
	// this is darren's scan function
	int ballSize = 150; //half of the ball, depend on curve
	if((abs(Msensor-Lsensor)>ballSize) && (abs(Msensor-Rsensor)>ballSize)){

		return Msensor;
	}
	else{

		return 100000;
	}

}

void rotate60(int dist) {
while (dist==100000) {
	motor(motor1) = -25;
	motor(motor2) = -25;
	wait1Msec(1000);
	motor(motor1) = 25;
	motor(motor2) = 25;
	wait1Msec(1000);
}
}

void scoop()
{


	motor(scoopmotor) = 50;
	wait1Msec(400);
	motor(scoopmotor) = 0;
	wait1Msec(2000);
	// 250 causes a roughly 60 degree rotation

}

void travelToBall(int dist) {
	int travelDist = dist - 50;
	motor(motor1)=-travelDist*127;
	motor(motor2)=travelDist*127;
	int timeToGo = 500; //adjusted based on how long it takes to move to ball
	wait1Msec(timeToGo);
	motor(motor1)=-travelDist*127;
	motor(motor2)=travelDist*127;

}

void deliver()
{
	motor(scoopmotor) = 127;
	wait1Msec(450);
	motor(scoopmotor) = 0;
	wait1Msec(2000);

}


void toDelPos() {

	while ((SensorValue(compassWest)!= 1)&&(SensorValue(compassNorth)!= 1)
		&&(SensorValue(compassEast)!= 0)&&(SensorValue(compassSouth)!= 0)){
			motor(motor1) = -25;
			motor(motor2) = -25;
	}

	motor(motor1) = 0;
	motor(motor2) = 0;

}

task main()

{
	while(true) {
		int corner = lineScan();
		int dist=detectBall();
		int ballDone = 0;

		while (corner==0) {

			while (dist==100000){

				if (ballDone<3) {
					moveFwd();
					rotate60(dist);
				}
			}
			if (dist<100000){
				travelToBall(dist);
				scoop();
				toDelPos(); //north west is the right direction
				reverse();
				deliver();
				ballDone++;


		}}
		
	}
	SideRun(); //do the linescanning and side limit hit move away code 
	
	// reverse if you hit front edge 
}
